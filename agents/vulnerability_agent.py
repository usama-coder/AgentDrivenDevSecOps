from chains.scan_chain import scan_chain
from chains.remediation_chain import run_remediation_chain
import subprocess


def get_modified_files():

    result = subprocess.run(['git', 'diff', '--name-only', 'HEAD~1', 'HEAD'], capture_output=True, text=True)
    files = result.stdout.splitlines()
    modified_files = [f for f in files if f.endswith('.py')]  # Only include Python files
    return modified_files


def generate_markdown_report(issues):
    report = "# Code Vulnerabilities Report\n\n"
    for issue in issues:
        report += f"### File: {issue['file']}, Line: {issue['line']}\n"
        report += f"**Description**: {issue['description']}\n\n"
        report += f"**Severity**: {issue['severity']}\n\n"
        report += "#### Bad Practice\n"
        report += "```python\n"
        report += f"{issue['bad_practice']}\n"
        report += "```\n\n"
        report += "#### Good Practice\n"
        report += "```python\n"
        report += f"{issue['good_practice']}\n"
        report += "```\n\n"
        report += "---\n\n"

    # Save the report as a Markdown file
    with open("vulnerability_report.md", "w") as f:
        f.write(report)

def handle_vulnerability():
    """
    Handles scanning and returns the list of detected vulnerabilities.
    """
    # Get the list of modified files
    modified_files = get_modified_files()  # Assuming this function exists and returns a list of files

    # Run the scan on modified files if any are found
    if modified_files:
        print(f"Scanning modified files: {modified_files}")
        report = scan_chain(modified_files)  # scan_chain should return structured vulnerability data
        return report
    else:
        print("No modified Python files to scan.")
        return {"issues": []}  # Return an empty issues list if no files are modified
