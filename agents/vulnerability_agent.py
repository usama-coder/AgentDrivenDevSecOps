from chains.scan_chain import scan_chain
from chains.remediation_chain import run_remediation_chain
import subprocess


def get_modified_files():
    # Use git diff to list modified files between the last two commits
    result = subprocess.run(['git', 'diff', '--name-only', 'HEAD~1', 'HEAD'], capture_output=True, text=True)
    files = result.stdout.splitlines()
    # Filter only Python files
    modified_files = [f for f in files if f.endswith('.py')]
    print(f"Modified files: {modified_files}")  # Debug print to check which files are found
    return modified_files


def generate_markdown_report(issues):
    report = "# Code Vulnerabilities Report\n\n"
    for issue in issues:
        # Query the LLM for a remediation for each issue
        remediation = run_remediation_chain(issue['description'])

        report += f"### File: {issue['file']}, Line: {issue['line']}\n"
        report += f"**Description**: {issue['description']}\n\n"
        report += f"**Severity**: {issue['severity']}\n\n"

        report += "#### Bad Practice\n"
        report += "```python\n"
        report += f"{issue['bad_practice']}\n"
        report += "```\n\n"

        report += "#### Good Practice\n"
        report += "```python\n"
        report += f"{issue['good_practice']}\n"
        report += "```\n\n"

        report += "#### LLM Recommended Code Fix\n"
        report += f"{remediation}\n\n"
        report += "---\n\n"

    # Save the report as a Markdown file
    with open("vulnerability_report.md", "w") as f:
        f.write(report)


def handle_vulnerability():
    """
    Handles scanning and returns the list of detected vulnerabilities.
    """
    # Get the list of modified files
    modified_files = get_modified_files()  # Assuming this function exists and returns a list of files

    # Run the scan on modified files if any are found
    if modified_files:
        print(f"Scanning modified files: {modified_files}")
        issues = scan_chain(modified_files)  # scan_chain should return structured vulnerability data
        return issues
    else:
        print("No modified Python files to scan.")
        return {"issues": []}  # Return an empty issues list if no files are modified
