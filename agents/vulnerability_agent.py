from chains.scan_chain import scan_chain
from chains.remediation_chain import run_remediation_chain
import subprocess


def get_modified_files():
    # Use git diff to list modified files between the last two commits
    result = subprocess.run(['git', 'diff', '--name-only', 'HEAD~1', 'HEAD'], capture_output=True, text=True)
    files = result.stdout.splitlines()
    # Filter only Python files
    modified_files = [f for f in files if f.endswith('.py')]
    print(f"Modified files: {modified_files}")
    return modified_files


def generate_markdown_report(issues):
    report = "# Code Vulnerabilities Report\n\n"

    for issue in issues:
        if isinstance(issue, dict) and "code" in issue and "description" in issue:
            remediation = run_remediation_chain(issue['code'] + issue['description'])
            sections = remediation.split("---")
            for section in sections:
                if "Vulnerable Code:" in section and "Recommended Fix:" in section:
                    # Extract the Vulnerable Code, Recommended Fix code, and Description
                    vulnerable_code = section.split("Recommended Fix:")[0].replace("Vulnerable Code:", "").strip()
                    recommended_fix_full = section.split("Recommended Fix:")[-1].strip()

                    # Further split Recommended Fix into code and description
                    if "\n\n" in recommended_fix_full:
                        recommended_fix_code, recommendation_description = recommended_fix_full.split("\n\n", 1)
                    else:
                        recommended_fix_code = recommended_fix_full
                        recommendation_description = "No additional description provided."

                    # Clean up nested code block delimiters in vulnerable and fix code sections
                    vulnerable_code = vulnerable_code.replace("```python", "").replace("```", "").strip()
                    recommended_fix_code = recommended_fix_code.replace("```python", "").replace("```", "").strip()
                    # Remove any unwanted prefix from recommendation description
                    recommendation_description = (
                        recommendation_description
                        .replace("Recommended Fix Description:", "")
                        .replace("recommended fix description:", "")
                        .replace("Recommended fix description:", "")
                        .strip()
                    )

                    # Build the report for each issue
                    report += f"### File: {issue['file']}, Line: {issue['line']}\n"
                    report += f"**Issue Description**: {issue['description']}\n\n"
                    report += f"**Severity**: {issue['severity']}\n\n"

                    # Display the vulnerable code
                    report += "#### Vulnerable Code\n"
                    report += "```python\n"
                    report += f"{vulnerable_code}\n"
                    report += "```\n\n"

                    # Display the recommended fix code
                    report += "#### Recommended Fix Code\n"
                    report += "```python\n"
                    report += f"{recommended_fix_code}\n"
                    report += "```\n\n"

                    # Display the recommendation description
                    report += "#### Recommendation Description\n"
                    report += f"{recommendation_description}\n\n"

                    report += "---\n\n"
        else:
            print(f"Skipping invalid issue format: {issue}")


    # Save the report as a Markdown file
    with open("vulnerability_report.md", "w") as f:
        f.write(report)


def handle_vulnerability():
    """
    Handles scanning and returns the list of detected vulnerabilities.
    """
    # Get the list of modified files
    modified_files = get_modified_files()  # Assuming this function exists and returns a list of files

    # Run the scan on modified files if any are found
    if modified_files:
        print(f"Scanning modified files: {modified_files}")
        issues = scan_chain(modified_files)  # scan_chain should return structured vulnerability data
        return issues
    else:
        print("No modified Python files to scan.")
        return {"issues": []}  # Return an empty issues list if no files are modified
